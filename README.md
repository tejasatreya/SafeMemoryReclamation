# C++ Implementation of Safe Memory Reclamation schemes for Lock-Free Concurrent Data Structures

Memory reclamation for a lock based structure is very straightforward and a node can be reclaimed when no lock is held on it. A lock based concurrent data structure ensures that as long as an operation is pending on the objects of a data structure, the lock on them is not released. The results in a simple check to verify if any thread still holds reference (that is, working on) to an object. However, in a lock free concurrent data structure, this verification is not trivial. If we reclaim a node without proper checking, it could lead to read-reclaim races. For example, overlapping reclaim and read calls could result in the read reading the address of an object which is then reclaimed. And when the read call tries to dereference the address, it will get a garbage value. In scenarios such as this one, improper garbage collection may violate legality of a data structure and could also violate progress properties.

In this project we have implemented two types of Memory Reclamation techniques, Epoch-Based Reclamation (EBR) and Interval-Based Reclamation (IBR). In the EBR scheme, each thread will try to reserve all the memory blocks that were created after a certain time. However, in IBR based schemes, only a set of processes will be able to reserve a block based on a time-interval and based on their existence/lifetime as an active reference for at least one thread. The IBR strategy is a stronger strategy as it will allow other threads to be released in case of one of the thread being stuck in a stall. The EBR strategy blocks all the threads in such a scenario and has very problematic consequences in terms of memory exhaustion. IBR provides a great solution to this by giving us a time interval or a window so to say, to check if the retired processes lie beyond the window of being reclaimed. If they do, we reclaim them without having to run a validation or a checking operation on them. 


n EBR scheme each thread tries to reserve all memory blocks that are created after a particular time, however IBR scheme only reserves a set of blocks that are created between a particular time interval. IBR approach is enhancement over EBR approach as this approach provides efficient solution of stalled threads as well. In EBR, if a thread gets stalled, it may prevent other threads from reclaiming the memory blocks that were created after a particular time point, since this algorithm tends to reserve all the memory blocks after a particular point of time. So, even a single thread stall might lead to memory exhaustion. IBR technique, fortunately, resolves this problem, as it only reserves certain set of memory blocks, which allows other threads to free the memory blocks which are not reserved by stalled thread.
